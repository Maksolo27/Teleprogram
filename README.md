# Teleprogram

#### Питання 1
Inversion of Control — це принцип, набір рекомендацій для написання слабо пов'язаного коду. Його ідея полягає в тому, що кожен компонент системи повинен бути якомога ізольованішим від інших, не покладаючись у своїй роботі на деталі конкретної реалізації інших компонентів

IoC container реалізовує автоматичне впровадження залежностей. Він керує створенням об'єкта та його лайфтаймом, а також впроваджує залежність у клас.
IoC container створює об'єкт і впроваджує всі об'єкти залежностей через конструктор, властивість чи метод під час виконання та видаляє їх у відповідний час. Це зроблено для того, щоб нам не доводилося створювати об'єкти та керувати ними вручну.

Dependecny injection це процес надання програмному компоненту зовнішньої залежності, це і є реалізацією IoC

Dependency inversion principle говорить про те, що високорівневі модулі не повинні залежати від низькорівневих і ті та інші повинні залежати від абстракцій,а вони не повинні залежати від деталей, деталі повинні залежати від абстракцій

Цей принцип зводиться до таких правил:

Взаємодія між класами має бути реалізована через інтерфейси чи абстрактні класи

Типами всіх членів класів мають бути інтерфейси або абстрактні
класи

Класи, які є кінцевими
реалізаціями не повинні розширюватися або мають бути фінальними

Аналогічно методи не повинні перекриватися під час наслідування або
бути фінальними

#### Питання 2
@Bean використовується в конфігураційних класах Spring. Він використовується для безпосереднього створення і налаштування біну.
@Component використовується з усіма класами, якими має керувати Spring для автоматичного виявлення і налаштування bean компонентів. Коли Spring бачить клас із @Component, Spring визначає цей клас як кандидата для створення bean.

#### Питання 3

1.Порушення принципу єдиної відповідальності

Немає жодної проблеми додати шість, десять або навіть більше залежностей. При використанні конструкторів для впровадження, після
Певного моменту кількість аргументів конструктора стає занадто великим і відразу стає очевидно, що щось не так. Наявність занадто великої кількості залежностей зазвичай означає, що клас має занадто багато зон відповідальності. 
Це може бути порушенням принципів єдиної відповідальності та поділу відповідальності і є хорошим індикатором, що клас можливо варто уважніше вивчити і піддати рефакторингу. 
При використанні впровадження через поля такого явного тривожного індикатора немає, і таким чином відбувається необмежене розростання впроваджених залежностей.

2.Приховування залежностей

Використання DI-контейнера означає, що клас не відповідає за керування його залежностями. Відповідальність за них отримання виноситься з класу за межі і тепер хтось інший відповідальний за їх надання: це може бути DI-контейнер
або ручне надання їх через тести. Коли клас більше не відповідає за здобуття залежностей, він повинен явно взаємодіяти з ними, використовуючи публічні інтерфейси – методи чи конструктори. Таким чином стає чітко зрозуміло, що вимагає клас, а також опціональні це залежність (через сеттери) або обов'язкові (конструктор)

3.Незмінність

На відміну від способу з використанням
конструктора, використання через поля не може використовуватися для присвоєння залежностей final-полям, що призводить до того, що ваші об'єкти стають змінними.

#### Питання 4

Сетери слід використовувати для ін'єкцій опціональних залежностей. Клас повинен бути здатним функціонувати, навіть якщо вони не були надані. Залежності можуть бути змінені будь-коли після створення об'єкта. Це може бути, а може, і не бути перевагою залежно від обставин. 

Ін'єкція через конструктори підходить для обов'язкових залежностей, які потрібні для коректної функціональності об'єкта. Передаючи їх через конструктор, ми можемо бути впевненими, що об'єкт повністю готовий до використання з моменту
створення. Поля, присвоєні в конструкторі, також можуть бути final, що дозволяє об'єкту бути повністю незмінним або, як мінімум, захищає необхідні поля.
Один із наслідків використання впровадження через конструктор — це те, що тепер неможлива циклічна залежність між двома об'єктами, створеними в такий спосіб (на відміну впровадження через сеттер). Це швидше плюс, ніж обмеження, оскільки слід уникати циклічних залежностей.

#### Питання 5

Singleton

Для bean-компонентів, які вимагають дорогих ресурсів під час запуску, таких як з'єднання з базою даних.
Для bean-компонентів, які використовуються для кешування та обміну даними у додатку.

Prototype

Компоненти з відстеження стану, які виконують мету одного виклику або одного використання.
Для сутностей, які потребують підтримки Spring. Наприклад, якщо є обліковий запис, де кожен обліковий запис містить різні дані. Кожен обліковий запис може бути prototype bean компонента. Protoype можна використовувати, якщо нам потрібно використовувати функціональні можливості Spring усередині кожного екземпляра облікового запису, наприклад, виконувати виклики інших компонентів Spring. Іноді можуть знадобитися такі незвичайні рішення.

#### Питання 6

Так, можливо через сетери.

#### Питання 7 

Так

#### Питання 8

Так, сетери.

#### Питання 9

Тільки один анотований конструктор для кожного класу може бути помічений як обов'язковий, але може бути анотовано кілька необов'язкових конструкторів. У цьому випадку кожен розглядається серед кандидатів, і Spring використовує найжадібніший
конструктор, чиї залежності можуть бути задоволені, тобто конструктор із найбільшою кількістю аргументів. Алгоритм дозволу конструктора такий самий, як і для неанотованих класів з перевантаженими конструкторами, просто звужуючи кількість кандидатів до анотованих конструкторів.
